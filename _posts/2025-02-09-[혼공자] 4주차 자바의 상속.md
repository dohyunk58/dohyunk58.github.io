--- 
title : "[혼공자] 4주차 자바의 상속"
excerpt : "자바의 상속에 대해 학습했습니다."
categories :
    - Java
layout: single
header:
    overlay_image: "/assets/img/2025-02-09-%5B혼공자%5D-4주차-자바의-상속/banner.jpg"
    overlay_filter: 0.5 # same as adding an opacity of 0.5 to a black background

---

![http://hongong.hanbit.co.kr/wp-content/uploads/2025/02/%ED%98%BC%EA%B3%B5%ED%95%99%EC%8A%B5%EB%8B%A8-13%EA%B8%B0_3%EC%A3%BC%EC%B0%A8.png](http://hongong.hanbit.co.kr/wp-content/uploads/2025/02/%ED%98%BC%EA%B3%B5%ED%95%99%EC%8A%B5%EB%8B%A8-13%EA%B8%B0_3%EC%A3%BC%EC%B0%A8.png)

벌써 50%나 달성했다. 2025년 2월이기도 하니까 1월을 알차게 보냈다는 뜻이기도 하겠지…!

학교 동아리에서 스프링부트 스터디를 진행하면서 코멘트를 달아주는데, 이 수많은 사람들의 글을 하나하나 다 읽고 코멘트를 다는 일이 얼마나 대단한 일인지 다시 한 번 느꼈다. (존경합니다 족장님 괜히 “족장”이라는 이름이 아니에요 정말)

그리고 다음 혼공학습단에 지원하시는 분이 참고하면 좋은 점인데, 가끔 아래와 같은 이벤트를 한다. 이번에는 돌려돌려 돌림판 이벤트로, 도서를 추첨하여 증정해준다! 한빛미디어 sns를 팔로우하며 새로 나온 책들을 자주 보는 편인데, 이번 이벤트로 증정하는 책은 바로바로 CS 지식의 정수이자 개발자들의 친구(?) 알고리즘이다.

![http://hongong.hanbit.co.kr/wp-content/uploads/2025/02/%ED%98%BC%EA%B3%B5%ED%95%99%EC%8A%B5%EB%8B%A8-13%EA%B8%B0_%EB%8F%8C%EB%A0%A4%EB%8F%8C%EB%A0%A4%EB%8F%8C%EB%A6%BC%ED%8C%90.png](http://hongong.hanbit.co.kr/wp-content/uploads/2025/02/%ED%98%BC%EA%B3%B5%ED%95%99%EC%8A%B5%EB%8B%A8-13%EA%B8%B0_%EB%8F%8C%EB%A0%A4%EB%8F%8C%EB%A0%A4%EB%8F%8C%EB%A6%BC%ED%8C%90.png)

당첨이 되지 않아도 알고리즘 책은 하나 구매할 예정이다. 지난해 자료구조와 알고리즘 수업을 학습하고 아직 정리가 덜 된 느낌이다. 물론 이번 학기에 듣는 운영체제도 마찬가지로 구매해야겠지만..!

아래는 이번 5주차에 해당하는 상속에 관한 내용과 숙제이다.

# 상속

자바에서는 부모 클래스에서 멤버를 자식 클래스로 물려줄 수 있다. 

멤버를 상속한다면 기존의 코드를 재사용하므로 중복을 줄일 수 있다.

## 클래스 상속

`extends` 이후 부모 클래스를 작성해 상속받는다.

```java
class 자식클래스 extends 부모클래스 {
}
```

**특징**

- 하나의 부모 클래스에서만 상속받을 수 있음 (단일 상속)
- 부모 클래스에서 private 접근 제한자가 붙은 멤버는 상속받을 수 없음
    - 다른 패키지에 존재하는 경우, default 접근 제한자가 붙은 멤버를 상속받을 수 없음

### 부모 생성자 호출

부모 객체가 생성된 후 자식 객체를 생성할 수 있다.

따라서 자식 객체의 생성자를 정의하지 않는다면, 아래 코드와 같은 기본 생성자가 자동으로 만들어진다.

```java
public 자식클래스() {
	super();
}
```

`super()` 는 부모의 기본 생성자를 호출한다. 따라서 부모 객체를 생성하고 자식 클래스가 만들지는 것을 알 수 있다. 자동으로 만들어지는 super()는 부모 클래스의 기본 생성자를 호출하므로, `부모 클래스의 기본 생성자가 없는 경우`에는 super()에 알맞은 매개 변수를 넣어 명시적으로 호출해야한다.

또한, super()을 사용할 때에는 자식 클래스의 가장 첫 줄에 작성한다.

## 메소드 overriding

메소드 오버라이딩은 메소드를 재정의하는 것으로, 부모 클래스의 메소드를 자식 클래스에 맞게 수정하는 것이다.

다만, 다음과 같은 규칙을 지켜야한다.

- 부모 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 목록)
- 접근 제한을 더 강하게 정할 수 없음
- 새로운 예외를 throw할 수 없음

<aside>
✨

접근 제한자를 강하게/약하게 설정하기

만약 접근 제한자가 public에서 private으로 변경되면 강하게 설정된 것이고, 그 반대라면 약하게 설정된 것이다.

접근 제한자의 순서는 public < protected < default < private

</aside>

![https://hongong.hanbit.co.kr/wp-content/uploads/2021/09/01-%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C%EC%9E%90_public_private-800x411.png](https://hongong.hanbit.co.kr/wp-content/uploads/2021/09/01-%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C%EC%9E%90_public_private-800x411.png)

**재정의 방법**

메소드 위에 `@Override` 를 적어 메소드 재정의임을 명시하고, 아래 메소드를 작성한다.

**부모 클래스 메소드 호출**

메소드 재정의 이후 부모 클래스의 메소드를 호출하려면, `super.부모메소드()` 를 사용한다.

## final 클래스와 final 메소드

필드에 final 키워드가 붙으면 `수정이 불가능함`을,
클래스에 final 키워드가 붙으면 `상속할 수 없음`을,
메소드에 final 키워드가 붙으면 `재정의할 수 없음`을 나타낸다.

예를 들어

`public final class Car{}` 라는 클래스가 있다면, 해당 클래스는 부모 클래스가 될 수 없다.

`public final int add(매개변수)` 라는 메소드가 있다면, 해당 메소드는 자식 클래스에서 재정의될 수 없다.

## protected 접근 제한자

# 02 타입 변환과 다형성

# 03 추상 클래스

# 숙제 01 클래스 타입 변환

클래스의 타입 변환에는 어떤 것이 있는지 정리하고 공유하기

{:notice}

# 숙제 02 추상 클래스 문제 풀이

HttpServlet이라는 추상 클래스가 다음과 같이 선언되어 있다.

```java
public abstract class HttpServlet {
	public abstract void service();
}
```

다음 클래스를 실행하면 “로그인 합니다.”, “파일 다운로드 합니다.”다 차례로 출력되도록 LoginServlet과 FileDownloadServlet 클래스를 선언하라.

```java
public class HttpServletExample {
	public static void main(String[] args) {
		method(new LoginServlet());
		method(new FileDownloadServlet());
	}
	
	public static void method(HttpServlet servlet) {
		servlet.service();
	}
}
```